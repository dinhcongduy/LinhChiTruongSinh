{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = exports.SequentialConnectionStrategy = exports.ParallelConnectionStrategy = void 0;\n\nvar _net = _interopRequireDefault(require(\"net\"));\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = void 0;\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n\n}\n\nclass ParallelConnectionStrategy {\n  constructor(addresses, signal, options) {\n    this.addresses = void 0;\n    this.options = void 0;\n    this.signal = void 0;\n    this.addresses = addresses;\n    this.options = options;\n    this.signal = signal;\n  }\n\n  connect(callback) {\n    const signal = this.signal;\n\n    if (signal.aborted) {\n      return process.nextTick(callback, new AbortError());\n    }\n\n    const addresses = this.addresses;\n    const sockets = new Array(addresses.length);\n    let errorCount = 0;\n\n    function onError(_err) {\n      errorCount += 1;\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n      this.destroy();\n\n      if (errorCount === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n        callback(new Error('Could not connect (parallel)'));\n      }\n    }\n\n    function onConnect() {\n      signal.removeEventListener('abort', onAbort);\n\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(null, this);\n    }\n\n    const onAbort = () => {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(new AbortError());\n    };\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = _net.default.connect({ ...this.options,\n        host: addresses[i].address,\n        family: addresses[i].family\n      });\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n\n    signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n  }\n\n}\n\nexports.ParallelConnectionStrategy = ParallelConnectionStrategy;\n\nclass SequentialConnectionStrategy {\n  constructor(addresses, signal, options) {\n    this.addresses = void 0;\n    this.options = void 0;\n    this.signal = void 0;\n    this.addresses = addresses;\n    this.options = options;\n    this.signal = signal;\n  }\n\n  connect(callback) {\n    if (this.signal.aborted) {\n      return process.nextTick(callback, new AbortError());\n    }\n\n    const next = this.addresses.shift();\n\n    if (!next) {\n      return callback(new Error('Could not connect (sequence)'));\n    }\n\n    const socket = _net.default.connect({ ...this.options,\n      host: next.address,\n      family: next.family\n    });\n\n    const onAbort = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      callback(new AbortError());\n    };\n\n    const onError = _err => {\n      this.signal.removeEventListener('abort', onAbort);\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      this.connect(callback);\n    };\n\n    const onConnect = () => {\n      this.signal.removeEventListener('abort', onAbort);\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      callback(null, socket);\n    };\n\n    this.signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n}\n\nexports.SequentialConnectionStrategy = SequentialConnectionStrategy;\n\nclass Connector {\n  constructor(options, signal, multiSubnetFailover) {\n    var _options$lookup;\n\n    this.options = void 0;\n    this.multiSubnetFailover = void 0;\n    this.lookup = void 0;\n    this.signal = void 0;\n    this.options = options;\n    this.lookup = (_options$lookup = options.lookup) !== null && _options$lookup !== void 0 ? _options$lookup : _dns.default.lookup;\n    this.signal = signal;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  execute(cb) {\n    if (this.signal.aborted) {\n      return process.nextTick(cb, new AbortError());\n    }\n\n    this.lookupAllAddresses(this.options.host, (err, addresses) => {\n      if (this.signal.aborted) {\n        return cb(new AbortError());\n      }\n\n      if (err) {\n        return cb(err);\n      }\n\n      if (this.multiSubnetFailover) {\n        new ParallelConnectionStrategy(addresses, this.signal, this.options).connect(cb);\n      } else {\n        new SequentialConnectionStrategy(addresses, this.signal, this.options).connect(cb);\n      }\n    });\n  }\n\n  lookupAllAddresses(host, callback) {\n    if (_net.default.isIPv6(host)) {\n      process.nextTick(callback, null, [{\n        address: host,\n        family: 6\n      }]);\n    } else if (_net.default.isIPv4(host)) {\n      process.nextTick(callback, null, [{\n        address: host,\n        family: 4\n      }]);\n    } else {\n      this.lookup.call(null, punycode.toASCII(host), {\n        all: true\n      }, callback);\n    }\n  }\n\n}\n\nexports.Connector = Connector;","map":{"version":3,"sources":["D:/Bakery/Bakery_ReactjsSourceCode/node_modules/tedious/lib/connector.js"],"names":["Object","defineProperty","exports","value","Connector","SequentialConnectionStrategy","ParallelConnectionStrategy","_net","_interopRequireDefault","require","_dns","punycode","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","AbortError","Error","constructor","code","name","addresses","signal","options","connect","callback","aborted","process","nextTick","sockets","Array","length","errorCount","onError","_err","removeListener","onConnect","destroy","removeEventListener","onAbort","j","socket","i","len","host","address","family","on","addEventListener","once","next","shift","multiSubnetFailover","_options$lookup","lookup","execute","cb","lookupAllAddresses","err","isIPv6","isIPv4","toASCII","all"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = exports.SequentialConnectionStrategy = exports.ParallelConnectionStrategy = void 0;\n\nvar _net = _interopRequireDefault(require(\"net\"));\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = void 0;\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n\n}\n\nclass ParallelConnectionStrategy {\n  constructor(addresses, signal, options) {\n    this.addresses = void 0;\n    this.options = void 0;\n    this.signal = void 0;\n    this.addresses = addresses;\n    this.options = options;\n    this.signal = signal;\n  }\n\n  connect(callback) {\n    const signal = this.signal;\n\n    if (signal.aborted) {\n      return process.nextTick(callback, new AbortError());\n    }\n\n    const addresses = this.addresses;\n    const sockets = new Array(addresses.length);\n    let errorCount = 0;\n\n    function onError(_err) {\n      errorCount += 1;\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n      this.destroy();\n\n      if (errorCount === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n        callback(new Error('Could not connect (parallel)'));\n      }\n    }\n\n    function onConnect() {\n      signal.removeEventListener('abort', onAbort);\n\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(null, this);\n    }\n\n    const onAbort = () => {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(new AbortError());\n    };\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = _net.default.connect({ ...this.options,\n        host: addresses[i].address,\n        family: addresses[i].family\n      });\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n\n    signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n  }\n\n}\n\nexports.ParallelConnectionStrategy = ParallelConnectionStrategy;\n\nclass SequentialConnectionStrategy {\n  constructor(addresses, signal, options) {\n    this.addresses = void 0;\n    this.options = void 0;\n    this.signal = void 0;\n    this.addresses = addresses;\n    this.options = options;\n    this.signal = signal;\n  }\n\n  connect(callback) {\n    if (this.signal.aborted) {\n      return process.nextTick(callback, new AbortError());\n    }\n\n    const next = this.addresses.shift();\n\n    if (!next) {\n      return callback(new Error('Could not connect (sequence)'));\n    }\n\n    const socket = _net.default.connect({ ...this.options,\n      host: next.address,\n      family: next.family\n    });\n\n    const onAbort = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      callback(new AbortError());\n    };\n\n    const onError = _err => {\n      this.signal.removeEventListener('abort', onAbort);\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      this.connect(callback);\n    };\n\n    const onConnect = () => {\n      this.signal.removeEventListener('abort', onAbort);\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      callback(null, socket);\n    };\n\n    this.signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n}\n\nexports.SequentialConnectionStrategy = SequentialConnectionStrategy;\n\nclass Connector {\n  constructor(options, signal, multiSubnetFailover) {\n    var _options$lookup;\n\n    this.options = void 0;\n    this.multiSubnetFailover = void 0;\n    this.lookup = void 0;\n    this.signal = void 0;\n    this.options = options;\n    this.lookup = (_options$lookup = options.lookup) !== null && _options$lookup !== void 0 ? _options$lookup : _dns.default.lookup;\n    this.signal = signal;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  execute(cb) {\n    if (this.signal.aborted) {\n      return process.nextTick(cb, new AbortError());\n    }\n\n    this.lookupAllAddresses(this.options.host, (err, addresses) => {\n      if (this.signal.aborted) {\n        return cb(new AbortError());\n      }\n\n      if (err) {\n        return cb(err);\n      }\n\n      if (this.multiSubnetFailover) {\n        new ParallelConnectionStrategy(addresses, this.signal, this.options).connect(cb);\n      } else {\n        new SequentialConnectionStrategy(addresses, this.signal, this.options).connect(cb);\n      }\n    });\n  }\n\n  lookupAllAddresses(host, callback) {\n    if (_net.default.isIPv6(host)) {\n      process.nextTick(callback, null, [{\n        address: host,\n        family: 6\n      }]);\n    } else if (_net.default.isIPv4(host)) {\n      process.nextTick(callback, null, [{\n        address: host,\n        family: 4\n      }]);\n    } else {\n      this.lookup.call(null, punycode.toASCII(host), {\n        all: true\n      }, callback);\n    }\n  }\n\n}\n\nexports.Connector = Connector;"]},"metadata":{},"sourceType":"script"}