{"ast":null,"code":"/*\n * @copyright\n * Copyright © Microsoft Open Technologies, Inc.\n *\n * All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http: *www.apache.org/licenses/LICENSE-2.0\n *\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\n *\n * See the Apache License, Version 2.0 for the specific language\n * governing permissions and limitations under the License.\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar select = require('xpath.js');\n\nvar XMLSerializer = require('xmldom').XMLSerializer;\n\nvar constants = require('./constants');\n/**\n * @namespace XmlUtil\n * @private\n */\n\n\nvar XPATH_PATH_TEMPLATE = '*[local-name() = \\'LOCAL_NAME\\' and namespace-uri() = \\'NAMESPACE\\']';\n/**\n* The xpath implementation being used does not have a way of matching expanded namespace.\n* This method takes an xpath query and expands all of the namespaces involved.  It then\n* re-writes the query in to a longer form that directory matches the correct namespaces.\n* @private\n* @static\n* @memberOf XmlUtil\n* @param {string} xpath   The expath query string to expand.\n* @returns {string} An expanded xpath query.\n*/\n\nfunction expandQNames(xpath) {\n  var namespaces = constants.XmlNamespaces;\n  var pathParts = xpath.split('/');\n\n  for (var i = 0; i < pathParts.length; i++) {\n    if (pathParts[i].indexOf(':') !== -1) {\n      var QNameParts = pathParts[i].split(':');\n\n      if (QNameParts.length !== 2) {\n        throw new Error('Unable to parse XPath string : ' + xpath + ' : with QName : ' + pathParts[i]);\n      }\n\n      var expandedPath = XPATH_PATH_TEMPLATE.replace('LOCAL_NAME', QNameParts[1]);\n      expandedPath = expandedPath.replace('NAMESPACE', namespaces[QNameParts[0]]);\n      pathParts[i] = expandedPath;\n    }\n  }\n\n  return pathParts.join('/');\n}\n\nvar exports = {\n  /**\n   * Performs an xpath select that does appropriate namespace matching since the imported\n   * xpath module does not properly handle namespaces.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object} dom     A dom object created by the xmldom module\n   * @param  {string} xpath   An xpath expression\n   * @return {array}          An array of matching dom nodes.\n   */\n  xpathSelect: function (dom, xpath) {\n    return select(dom, expandQNames(xpath));\n  },\n\n  /**\n   * Given a dom node serializes all immediate children that are xml elements.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object} node  An xml dom node.\n   * @return {string}       Serialized xml.\n   */\n  serializeNodeChildren: function (node) {\n    var doc = '';\n    var sibling = node.firstChild;\n    var serializer = new XMLSerializer();\n\n    while (sibling) {\n      if (this.isElementNode(sibling)) {\n        doc += serializer.serializeToString(sibling);\n      }\n\n      sibling = sibling.nextSibling;\n    }\n\n    return doc !== '' ? doc : null;\n  },\n\n  /**\n   * Detects whether the passed in dom node represents an xml element.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object}  node   An xml dom node.\n   * @return {Boolean}        true if the node represents an element.\n   */\n  isElementNode: function (node) {\n    return _.has(node, 'tagName');\n  },\n\n  /**\n   * Given an xmldom node this function returns any text data contained within.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object} node  An xmldom node from which the data should be extracted.\n   * @return {string}       Any data found within the element or null if none is found.\n   */\n  findElementText: function (node) {\n    var sibling = node.firstChild;\n\n    while (sibling && !sibling.data) {\n      sibling = sibling.nextSibling;\n    }\n\n    return sibling.data ? sibling.data : null;\n  }\n};\nmodule.exports = exports;","map":{"version":3,"sources":["C:/Users/chant/Desktop/Bakery_ReactjsSourceCode/node_modules/adal-node/lib/xmlutil.js"],"names":["_","require","select","XMLSerializer","constants","XPATH_PATH_TEMPLATE","expandQNames","xpath","namespaces","XmlNamespaces","pathParts","split","i","length","indexOf","QNameParts","Error","expandedPath","replace","join","exports","xpathSelect","dom","serializeNodeChildren","node","doc","sibling","firstChild","serializer","isElementNode","serializeToString","nextSibling","has","findElementText","data","module"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,YAAD,CAAf;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,QAAD,CAAP,CAAkBE,aAAtC;;AAEA,IAAIC,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAvB;AAEA;AACA;AACA;AACA;;;AAEA,IAAII,mBAAmB,GAAG,sEAA1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAC3B,MAAIC,UAAU,GAAGJ,SAAS,CAACK,aAA3B;AACA,MAAIC,SAAS,GAAGH,KAAK,CAACI,KAAN,CAAY,GAAZ,CAAhB;;AACA,OAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAGF,SAAS,CAACG,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,QAAIF,SAAS,CAACE,CAAD,CAAT,CAAaE,OAAb,CAAqB,GAArB,MAA8B,CAAC,CAAnC,EAAsC;AACpC,UAAIC,UAAU,GAAGL,SAAS,CAACE,CAAD,CAAT,CAAaD,KAAb,CAAmB,GAAnB,CAAjB;;AACA,UAAII,UAAU,CAACF,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,cAAM,IAAIG,KAAJ,CAAU,oCAAoCT,KAApC,GAA4C,kBAA5C,GAAiEG,SAAS,CAACE,CAAD,CAApF,CAAN;AACD;;AACD,UAAIK,YAAY,GAAGZ,mBAAmB,CAACa,OAApB,CAA4B,YAA5B,EAA0CH,UAAU,CAAC,CAAD,CAApD,CAAnB;AACAE,MAAAA,YAAY,GAAGA,YAAY,CAACC,OAAb,CAAqB,WAArB,EAAkCV,UAAU,CAACO,UAAU,CAAC,CAAD,CAAX,CAA5C,CAAf;AACAL,MAAAA,SAAS,CAACE,CAAD,CAAT,GAAeK,YAAf;AACD;AACF;;AACD,SAAOP,SAAS,CAACS,IAAV,CAAe,GAAf,CAAP;AACD;;AAED,IAAIC,OAAO,GAAG;AAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,EAAI,UAAUC,GAAV,EAAef,KAAf,EAAsB;AACnC,WAAOL,MAAM,CAACoB,GAAD,EAAMhB,YAAY,CAACC,KAAD,CAAlB,CAAb;AACD,GAbW;;AAeZ;AACF;AACA;AACA;AACA;AACA;AACA;AACEgB,EAAAA,qBAAqB,EAAG,UAASC,IAAT,EAAe;AACrC,QAAIC,GAAG,GAAG,EAAV;AACA,QAAIC,OAAO,GAAGF,IAAI,CAACG,UAAnB;AACA,QAAIC,UAAU,GAAG,IAAIzB,aAAJ,EAAjB;;AAEA,WAAOuB,OAAP,EAAgB;AACd,UAAI,KAAKG,aAAL,CAAmBH,OAAnB,CAAJ,EAAiC;AAC/BD,QAAAA,GAAG,IAAIG,UAAU,CAACE,iBAAX,CAA6BJ,OAA7B,CAAP;AACD;;AACDA,MAAAA,OAAO,GAAGA,OAAO,CAACK,WAAlB;AACD;;AAED,WAAON,GAAG,KAAK,EAAR,GAAaA,GAAb,GAAmB,IAA1B;AACD,GAnCW;;AAqCZ;AACF;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,aAAa,EAAG,UAASL,IAAT,EAAe;AAC7B,WAAOxB,CAAC,CAACgC,GAAF,CAAMR,IAAN,EAAY,SAAZ,CAAP;AACD,GA9CW;;AAgDZ;AACF;AACA;AACA;AACA;AACA;AACA;AACES,EAAAA,eAAe,EAAG,UAAST,IAAT,EAAe;AAC/B,QAAIE,OAAO,GAAGF,IAAI,CAACG,UAAnB;;AACA,WAAOD,OAAO,IAAI,CAACA,OAAO,CAACQ,IAA3B,EAAiC;AAC/BR,MAAAA,OAAO,GAAGA,OAAO,CAACK,WAAlB;AACD;;AAED,WAAOL,OAAO,CAACQ,IAAR,GAAeR,OAAO,CAACQ,IAAvB,GAA8B,IAArC;AACD;AA9DW,CAAd;AAiEAC,MAAM,CAACf,OAAP,GAAiBA,OAAjB","sourcesContent":["/*\n * @copyright\n * Copyright © Microsoft Open Technologies, Inc.\n *\n * All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http: *www.apache.org/licenses/LICENSE-2.0\n *\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\n *\n * See the Apache License, Version 2.0 for the specific language\n * governing permissions and limitations under the License.\n */\n'use strict';\n\nvar _ = require('underscore');\nvar select = require('xpath.js');\nvar XMLSerializer = require('xmldom').XMLSerializer;\n\nvar constants = require('./constants');\n\n/**\n * @namespace XmlUtil\n * @private\n */\n\nvar XPATH_PATH_TEMPLATE = '*[local-name() = \\'LOCAL_NAME\\' and namespace-uri() = \\'NAMESPACE\\']';\n/**\n* The xpath implementation being used does not have a way of matching expanded namespace.\n* This method takes an xpath query and expands all of the namespaces involved.  It then\n* re-writes the query in to a longer form that directory matches the correct namespaces.\n* @private\n* @static\n* @memberOf XmlUtil\n* @param {string} xpath   The expath query string to expand.\n* @returns {string} An expanded xpath query.\n*/\nfunction expandQNames(xpath) {\n  var namespaces = constants.XmlNamespaces;\n  var pathParts = xpath.split('/');\n  for (var i=0; i < pathParts.length; i++) {\n    if (pathParts[i].indexOf(':') !== -1) {\n      var QNameParts = pathParts[i].split(':');\n      if (QNameParts.length !== 2) {\n        throw new Error('Unable to parse XPath string : ' + xpath + ' : with QName : ' + pathParts[i]);\n      }\n      var expandedPath = XPATH_PATH_TEMPLATE.replace('LOCAL_NAME', QNameParts[1]);\n      expandedPath = expandedPath.replace('NAMESPACE', namespaces[QNameParts[0]]);\n      pathParts[i] = expandedPath;\n    }\n  }\n  return pathParts.join('/');\n}\n\nvar exports = {\n\n  /**\n   * Performs an xpath select that does appropriate namespace matching since the imported\n   * xpath module does not properly handle namespaces.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object} dom     A dom object created by the xmldom module\n   * @param  {string} xpath   An xpath expression\n   * @return {array}          An array of matching dom nodes.\n   */\n  xpathSelect :  function (dom, xpath) {\n    return select(dom, expandQNames(xpath));\n  },\n\n  /**\n   * Given a dom node serializes all immediate children that are xml elements.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object} node  An xml dom node.\n   * @return {string}       Serialized xml.\n   */\n  serializeNodeChildren : function(node) {\n    var doc = '';\n    var sibling = node.firstChild;\n    var serializer = new XMLSerializer();\n\n    while (sibling) {\n      if (this.isElementNode(sibling)) {\n        doc += serializer.serializeToString(sibling);\n      }\n      sibling = sibling.nextSibling;\n    }\n\n    return doc !== '' ? doc : null;\n  },\n\n  /**\n   * Detects whether the passed in dom node represents an xml element.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object}  node   An xml dom node.\n   * @return {Boolean}        true if the node represents an element.\n   */\n  isElementNode : function(node) {\n    return _.has(node, 'tagName');\n  },\n\n  /**\n   * Given an xmldom node this function returns any text data contained within.\n   * @static\n   * @memberOf XmlUtil\n   * @param  {object} node  An xmldom node from which the data should be extracted.\n   * @return {string}       Any data found within the element or null if none is found.\n   */\n  findElementText : function(node) {\n    var sibling = node.firstChild;\n    while (sibling && !sibling.data) {\n      sibling = sibling.nextSibling;\n    }\n\n    return sibling.data ? sibling.data : null;\n  }\n};\n\nmodule.exports = exports;"]},"metadata":{},"sourceType":"script"}