{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstanceLookup = void 0;\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar _nodeAbortController = _interopRequireDefault(require(\"node-abort-controller\"));\n\nvar _sender = require(\"./sender\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nconst MYSTERY_HEADER_LENGTH = 3;\n\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = void 0;\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n\n} // Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\n\n\nclass InstanceLookup {\n  instanceLookup(options, callback) {\n    var _options$lookup, _options$port;\n\n    const server = options.server;\n\n    if (typeof server !== 'string') {\n      throw new TypeError('Invalid arguments: \"server\" must be a string');\n    }\n\n    const instanceName = options.instanceName;\n\n    if (typeof instanceName !== 'string') {\n      throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n    }\n\n    const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n\n    if (typeof timeout !== 'number') {\n      throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n    }\n\n    const retries = options.retries === undefined ? RETRIES : options.retries;\n\n    if (typeof retries !== 'number') {\n      throw new TypeError('Invalid arguments: \"retries\" must be a number');\n    }\n\n    if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n      throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n    }\n\n    const lookup = (_options$lookup = options.lookup) !== null && _options$lookup !== void 0 ? _options$lookup : _dns.default.lookup;\n\n    if (options.port !== undefined && typeof options.port !== 'number') {\n      throw new TypeError('Invalid arguments: \"port\" must be a number');\n    }\n\n    const port = (_options$port = options.port) !== null && _options$port !== void 0 ? _options$port : SQL_SERVER_BROWSER_PORT;\n    const signal = options.signal;\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Invalid arguments: \"callback\" must be a function');\n    }\n\n    if (signal.aborted) {\n      return process.nextTick(callback, new AbortError());\n    }\n\n    let retriesLeft = retries;\n\n    const makeAttempt = () => {\n      if (retriesLeft >= 0) {\n        retriesLeft--;\n        const controller = new _nodeAbortController.default();\n\n        const abortCurrentAttempt = () => {\n          controller.abort();\n        }; // If the overall instance lookup is aborted,\n        // forward the abort to the controller of the current\n        // lookup attempt.\n\n\n        signal.addEventListener('abort', abortCurrentAttempt, {\n          once: true\n        });\n        const request = Buffer.from([0x02]);\n        const sender = new _sender.Sender(options.server, port, lookup, controller.signal, request);\n        const timer = setTimeout(abortCurrentAttempt, timeout);\n        sender.execute((err, response) => {\n          clearTimeout(timer);\n\n          if (err) {\n            if ((err === null || err === void 0 ? void 0 : err.name) === 'AbortError') {\n              // If the overall instance lookup was aborted,\n              // do not perform any further attempts.\n              if (signal.aborted) {\n                return callback(new AbortError());\n              }\n\n              return makeAttempt();\n            }\n\n            return callback(new Error('Failed to lookup instance on ' + server + ' - ' + err.message));\n          }\n\n          const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n          const port = this.parseBrowserResponse(message, instanceName);\n\n          if (port) {\n            callback(undefined, port);\n          } else {\n            callback(new Error('Port for ' + instanceName + ' not found in ' + options.server));\n          }\n        });\n      } else {\n        callback(new Error('Failed to get response from SQL Server Browser on ' + server));\n      }\n    };\n\n    makeAttempt();\n  }\n\n  parseBrowserResponse(response, instanceName) {\n    let getPort;\n    const instances = response.split(';;');\n\n    for (let i = 0, len = instances.length; i < len; i++) {\n      const instance = instances[i];\n      const parts = instance.split(';');\n\n      for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n        const name = parts[p];\n        const value = parts[p + 1];\n\n        if (name === 'tcp' && getPort) {\n          const port = parseInt(value, 10);\n          return port;\n        }\n\n        if (name === 'InstanceName') {\n          if (value.toUpperCase() === instanceName.toUpperCase()) {\n            getPort = true;\n          } else {\n            getPort = false;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexports.InstanceLookup = InstanceLookup;","map":{"version":3,"sources":["C:/Users/chant/Desktop/Bakery_ReactjsSourceCode/node_modules/tedious/lib/instance-lookup.js"],"names":["Object","defineProperty","exports","value","InstanceLookup","_dns","_interopRequireDefault","require","_nodeAbortController","_sender","obj","__esModule","default","SQL_SERVER_BROWSER_PORT","TIMEOUT","RETRIES","MYSTERY_HEADER_LENGTH","AbortError","Error","constructor","code","name","instanceLookup","options","callback","_options$lookup","_options$port","server","TypeError","instanceName","timeout","undefined","retries","lookup","port","signal","aborted","process","nextTick","retriesLeft","makeAttempt","controller","abortCurrentAttempt","abort","addEventListener","once","request","Buffer","from","sender","Sender","timer","setTimeout","execute","err","response","clearTimeout","message","toString","parseBrowserResponse","getPort","instances","split","i","len","length","instance","parts","p","partsLen","parseInt","toUpperCase"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstanceLookup = void 0;\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar _nodeAbortController = _interopRequireDefault(require(\"node-abort-controller\"));\n\nvar _sender = require(\"./sender\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nconst MYSTERY_HEADER_LENGTH = 3;\n\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = void 0;\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n\n} // Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\n\n\nclass InstanceLookup {\n  instanceLookup(options, callback) {\n    var _options$lookup, _options$port;\n\n    const server = options.server;\n\n    if (typeof server !== 'string') {\n      throw new TypeError('Invalid arguments: \"server\" must be a string');\n    }\n\n    const instanceName = options.instanceName;\n\n    if (typeof instanceName !== 'string') {\n      throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n    }\n\n    const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n\n    if (typeof timeout !== 'number') {\n      throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n    }\n\n    const retries = options.retries === undefined ? RETRIES : options.retries;\n\n    if (typeof retries !== 'number') {\n      throw new TypeError('Invalid arguments: \"retries\" must be a number');\n    }\n\n    if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n      throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n    }\n\n    const lookup = (_options$lookup = options.lookup) !== null && _options$lookup !== void 0 ? _options$lookup : _dns.default.lookup;\n\n    if (options.port !== undefined && typeof options.port !== 'number') {\n      throw new TypeError('Invalid arguments: \"port\" must be a number');\n    }\n\n    const port = (_options$port = options.port) !== null && _options$port !== void 0 ? _options$port : SQL_SERVER_BROWSER_PORT;\n    const signal = options.signal;\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Invalid arguments: \"callback\" must be a function');\n    }\n\n    if (signal.aborted) {\n      return process.nextTick(callback, new AbortError());\n    }\n\n    let retriesLeft = retries;\n\n    const makeAttempt = () => {\n      if (retriesLeft >= 0) {\n        retriesLeft--;\n        const controller = new _nodeAbortController.default();\n\n        const abortCurrentAttempt = () => {\n          controller.abort();\n        }; // If the overall instance lookup is aborted,\n        // forward the abort to the controller of the current\n        // lookup attempt.\n\n\n        signal.addEventListener('abort', abortCurrentAttempt, {\n          once: true\n        });\n        const request = Buffer.from([0x02]);\n        const sender = new _sender.Sender(options.server, port, lookup, controller.signal, request);\n        const timer = setTimeout(abortCurrentAttempt, timeout);\n        sender.execute((err, response) => {\n          clearTimeout(timer);\n\n          if (err) {\n            if ((err === null || err === void 0 ? void 0 : err.name) === 'AbortError') {\n              // If the overall instance lookup was aborted,\n              // do not perform any further attempts.\n              if (signal.aborted) {\n                return callback(new AbortError());\n              }\n\n              return makeAttempt();\n            }\n\n            return callback(new Error('Failed to lookup instance on ' + server + ' - ' + err.message));\n          }\n\n          const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n          const port = this.parseBrowserResponse(message, instanceName);\n\n          if (port) {\n            callback(undefined, port);\n          } else {\n            callback(new Error('Port for ' + instanceName + ' not found in ' + options.server));\n          }\n        });\n      } else {\n        callback(new Error('Failed to get response from SQL Server Browser on ' + server));\n      }\n    };\n\n    makeAttempt();\n  }\n\n  parseBrowserResponse(response, instanceName) {\n    let getPort;\n    const instances = response.split(';;');\n\n    for (let i = 0, len = instances.length; i < len; i++) {\n      const instance = instances[i];\n      const parts = instance.split(';');\n\n      for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n        const name = parts[p];\n        const value = parts[p + 1];\n\n        if (name === 'tcp' && getPort) {\n          const port = parseInt(value, 10);\n          return port;\n        }\n\n        if (name === 'InstanceName') {\n          if (value.toUpperCase() === instanceName.toUpperCase()) {\n            getPort = true;\n          } else {\n            getPort = false;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexports.InstanceLookup = InstanceLookup;"]},"metadata":{},"sourceType":"script"}