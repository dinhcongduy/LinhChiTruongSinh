{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar _regeneratorRuntime = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\n\nvar authConstants_1 = require(\"../util/authConstants\");\n\nvar ApplicationTokenCredentialsBase = /*#__PURE__*/function (_tokenCredentialsBase) {\n  _inherits(ApplicationTokenCredentialsBase, _tokenCredentialsBase);\n\n  var _super2 = _createSuper(ApplicationTokenCredentialsBase);\n\n  /**\n   * Creates a new ApplicationTokenCredentials object.\n   * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n   * for detailed instructions on creating an Azure Active Directory application.\n   * @constructor\n   * @param {string} clientId The active directory application client id.\n   * @param {string} domain The domain or tenant id containing this application.\n   * @param {string} [tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n   * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n   * @param {Environment} [environment] The azure environment to authenticate with.\n   * @param {object} [tokenCache] The token cache. Default value is the MemoryCache object from adal.\n   */\n  function ApplicationTokenCredentialsBase(clientId, domain, tokenAudience, environment, tokenCache) {\n    _classCallCheck(this, ApplicationTokenCredentialsBase);\n\n    return _super2.call(this, clientId, domain, tokenAudience, environment, tokenCache);\n  }\n\n  _createClass(ApplicationTokenCredentialsBase, [{\n    key: \"getTokenFromCache\",\n    value: function getTokenFromCache() {\n      var _this = this;\n\n      var _super = Object.create(null, {\n        getTokenFromCache: {\n          get: function get() {\n            return _get(_getPrototypeOf(ApplicationTokenCredentialsBase.prototype), \"getTokenFromCache\", _this);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var status, message;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return _super.getTokenFromCache.call(this, undefined);\n\n              case 3:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                _context.next = 10;\n                return this.removeInvalidItemsFromCache({\n                  _clientId: this.clientId\n                });\n\n              case 10:\n                status = _context.sent;\n\n                if (!status.result) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 13:\n                message = status && status.details && status.details.message ? status.details.message : status.details;\n                throw new Error(authConstants_1.AuthConstants.SDK_INTERNAL_ERROR + \" : \" + \"critical failure while removing expired token for service principal from token cache. \" + message);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n    }\n    /**\n     * Removes invalid items from token cache. This method is different. Here we never reject in case of error.\n     * Rather we resolve with an object that says the result is false and error information is provided in\n     * the details property of the resolved object. This is done to do better error handling in the above function\n     * where removeInvalidItemsFromCache() is called.\n     * @param {object} query The query to be used for finding the token for service principal from the cache\n     * @returns {result: boolean, details?: Error} resultObject with more info.\n     */\n\n  }, {\n    key: \"removeInvalidItemsFromCache\",\n    value: function removeInvalidItemsFromCache(query) {\n      var self = this;\n      return new Promise(function (resolve) {\n        self.tokenCache.find(query, function (error, entries) {\n          if (error) {\n            return resolve({\n              result: false,\n              details: error\n            });\n          }\n\n          if (entries && entries.length > 0) {\n            return self.tokenCache.remove(entries, function (err) {\n              if (err) {\n                return resolve({\n                  result: false,\n                  details: err\n                });\n              }\n\n              return resolve({\n                result: true\n              });\n            });\n          } else {\n            return resolve({\n              result: true\n            });\n          }\n        });\n      });\n    }\n  }]);\n\n  return ApplicationTokenCredentialsBase;\n}(tokenCredentialsBase_1.TokenCredentialsBase);\n\nexports.ApplicationTokenCredentialsBase = ApplicationTokenCredentialsBase;","map":{"version":3,"sources":["../../../lib/credentials/applicationTokenCredentialsBase.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAA,sBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,IAAA,eAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;IAGsB,+B;;;;;AACpB;;;;;;;;;;;AAWG;AACH,2CACE,QADF,EAEE,MAFF,EAGE,aAHF,EAIE,WAJF,EAKE,UALF,EAKyB;AAAA;;AAAA,8BAEjB,QAFiB,EAEP,MAFO,EAEC,aAFD,EAEgB,WAFhB,EAE6B,UAF7B;AAGxB;;;;wCAEgC;AAAA;;;;;;;;;;;;;;;;;;AAGtB,uBAAM,MAAA,CAAM,iBAAN,CAAuB,IAAvB,CAAuB,IAAvB,EAAwB,SAAxB,CAAN;;;;;;;;;AAKQ,uBAAM,KAAK,2BAAL,CAAiC;AACpD,kBAAA,SAAS,EAAE,KAAK;AADoC,iBAAjC,CAAN;;;AAAT,gBAAA,M;;qBAIF,MAAM,CAAC,M;;;;;;;;AAIL,gBAAA,O,GACJ,MAAM,IAAI,MAAM,CAAC,OAAjB,IAA4B,MAAM,CAAC,OAAP,CAAe,OAA3C,GACI,MAAM,CAAC,OAAP,CAAe,OADnB,GAEI,MAAM,CAAC,O;sBAEP,IAAI,KAAJ,CACJ,eAAA,CAAA,aAAA,CAAc,kBAAd,GACA,KADA,GAEA,wFAFA,GAGA,OAJI,C;;;;;;;;;AAOT;AAED;;;;;;;AAOG;;;;gDAED,K,EAAa;AAEb,UAAM,IAAI,GAAG,IAAb;AACA,aAAO,IAAI,OAAJ,CAAkD,UAAA,OAAO,EAAG;AACjE,QAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,KAArB,EAA4B,UAAC,KAAD,EAAe,OAAf,EAAiC;AAC3D,cAAI,KAAJ,EAAW;AACT,mBAAO,OAAO,CAAC;AAAE,cAAA,MAAM,EAAE,KAAV;AAAiB,cAAA,OAAO,EAAE;AAA1B,aAAD,CAAd;AACD;;AAED,cAAI,OAAO,IAAI,OAAO,CAAC,MAAR,GAAiB,CAAhC,EAAmC;AACjC,mBAAO,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAuB,OAAvB,EAAgC,UAAC,GAAD,EAAe;AACpD,kBAAI,GAAJ,EAAS;AACP,uBAAO,OAAO,CAAC;AAAE,kBAAA,MAAM,EAAE,KAAV;AAAiB,kBAAA,OAAO,EAAE;AAA1B,iBAAD,CAAd;AACD;;AACD,qBAAO,OAAO,CAAC;AAAE,gBAAA,MAAM,EAAE;AAAV,eAAD,CAAd;AACD,aALM,CAAP;AAMD,WAPD,MAOO;AACL,mBAAO,OAAO,CAAC;AAAE,cAAA,MAAM,EAAE;AAAV,aAAD,CAAd;AACD;AACF,SAfD;AAgBD,OAjBM,CAAP;AAkBD;;;;EAnF2D,sBAAA,CAAA,oB;;AAA9D,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\nconst authConstants_1 = require(\"../util/authConstants\");\nclass ApplicationTokenCredentialsBase extends tokenCredentialsBase_1.TokenCredentialsBase {\n    /**\n     * Creates a new ApplicationTokenCredentials object.\n     * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n     * for detailed instructions on creating an Azure Active Directory application.\n     * @constructor\n     * @param {string} clientId The active directory application client id.\n     * @param {string} domain The domain or tenant id containing this application.\n     * @param {string} [tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n     * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n     * @param {Environment} [environment] The azure environment to authenticate with.\n     * @param {object} [tokenCache] The token cache. Default value is the MemoryCache object from adal.\n     */\n    constructor(clientId, domain, tokenAudience, environment, tokenCache) {\n        super(clientId, domain, tokenAudience, environment, tokenCache);\n    }\n    getTokenFromCache() {\n        const _super = Object.create(null, {\n            getTokenFromCache: { get: () => super.getTokenFromCache }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // a thin wrapper over the base implementation. try get token from cache, additionaly clean up cache if required.\n            try {\n                return yield _super.getTokenFromCache.call(this, undefined);\n            }\n            catch (error) {\n                // Remove the stale token from the tokencache. ADAL gives the same error message \"Entry not found in cache.\"\n                // for entry not being present in the cache and for accessToken being expired in the cache. We do not want the token cache\n                // to contain the expired token, we clean it up here.\n                const status = yield this.removeInvalidItemsFromCache({\n                    _clientId: this.clientId\n                });\n                if (status.result) {\n                    throw error;\n                }\n                const message = status && status.details && status.details.message\n                    ? status.details.message\n                    : status.details;\n                throw new Error(authConstants_1.AuthConstants.SDK_INTERNAL_ERROR +\n                    \" : \" +\n                    \"critical failure while removing expired token for service principal from token cache. \" +\n                    message);\n            }\n        });\n    }\n    /**\n     * Removes invalid items from token cache. This method is different. Here we never reject in case of error.\n     * Rather we resolve with an object that says the result is false and error information is provided in\n     * the details property of the resolved object. This is done to do better error handling in the above function\n     * where removeInvalidItemsFromCache() is called.\n     * @param {object} query The query to be used for finding the token for service principal from the cache\n     * @returns {result: boolean, details?: Error} resultObject with more info.\n     */\n    removeInvalidItemsFromCache(query) {\n        const self = this;\n        return new Promise(resolve => {\n            self.tokenCache.find(query, (error, entries) => {\n                if (error) {\n                    return resolve({ result: false, details: error });\n                }\n                if (entries && entries.length > 0) {\n                    return self.tokenCache.remove(entries, (err) => {\n                        if (err) {\n                            return resolve({ result: false, details: err });\n                        }\n                        return resolve({ result: true });\n                    });\n                }\n                else {\n                    return resolve({ result: true });\n                }\n            });\n        });\n    }\n}\nexports.ApplicationTokenCredentialsBase = ApplicationTokenCredentialsBase;\n//# sourceMappingURL=applicationTokenCredentialsBase.js.map"]},"metadata":{},"sourceType":"script"}