{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar _regeneratorRuntime = require(\"D:/Bakery/Bakery_ReactjsSourceCode/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar adal = require(\"adal-node\");\n\nvar msRest = require(\"@azure/ms-rest-js\");\n\nvar child_process_1 = require(\"child_process\");\n\nvar fs_1 = require(\"fs\");\n\nvar ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\n\nvar applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\n\nvar applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\n\nvar deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\n\nvar userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\n\nvar authConstants_1 = require(\"./util/authConstants\");\n\nvar subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\n\nvar msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\n\nvar msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * @constant {Array<string>} managementPlaneTokenAudiences - Urls for management plane token\n * audience across different azure environments.\n */\n\n\nvar managementPlaneTokenAudiences = [\"https://management.core.windows.net/\", \"https://management.core.chinacloudapi.cn/\", \"https://management.core.usgovcloudapi.net/\", \"https://management.core.cloudapi.de/\", \"https://management.azure.com/\", \"https://management.core.windows.net\", \"https://management.core.chinacloudapi.cn\", \"https://management.core.usgovcloudapi.net\", \"https://management.core.cloudapi.de\", \"https://management.azure.com\"];\n\nfunction turnOnLogging() {\n  var log = adal.Logging;\n  log.setLoggingOptions({\n    level: 3,\n    log: function log(level, message, error) {\n      level;\n      console.info(message);\n\n      if (error) {\n        console.error(error);\n      }\n    }\n  });\n}\n\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n  turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {string} username The user name for the Organization Id account.\n * @param {string} password The password for the Organization Id account.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param {string} [options.domain] The domain or tenant Id containing this application. Default value \"common\".\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains `credentials` and an optional `subscriptions` array, and rejects with an Error.\n */\n\n\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var creds, tokenResponse, tenantList, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.clientId) {\n              options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n            }\n\n            if (!options.domain) {\n              options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment);\n            _context.next = 7;\n            return creds.getToken();\n\n          case 7:\n            tokenResponse = _context.sent;\n            _context.next = 10;\n            return subscriptionUtils_1.buildTenantList(creds);\n\n          case 10:\n            tenantList = _context.sent;\n\n            if (tenantList.length === 0 && tokenResponse.tenantId) {\n              tenantList = [tokenResponse.tenantId];\n            }\n\n            _context.next = 14;\n            return _getSubscriptions(creds, tenantList, options.tokenAudience);\n\n          case 14:\n            subscriptionList = _context.sent;\n            return _context.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptionList\n            });\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {string} clientId The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} secret The application secret for the service principal.\n * @param {string} domain The domain or tenant Id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var creds, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment);\n            _context2.next = 5;\n            return creds.getToken();\n\n          case 5:\n            _context2.next = 7;\n            return _getSubscriptions(creds, [domain], options.tokenAudience);\n\n          case 7:\n            subscriptionList = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptionList\n            });\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {string} clientId The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} certificateStringOrFilePath A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param {string} domain The domain or tenant Id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var creds, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n            _context3.next = 5;\n            return creds.getToken();\n\n          case 5:\n            _context3.next = 7;\n            return _getSubscriptions(creds, [domain], options.tokenAudience);\n\n          case 7:\n            subscriptionList = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptionList\n            });\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\n\nfunction validateAuthFileContent(credsObj, filePath) {\n  if (!credsObj) {\n    throw new Error(\"Please provide a credsObj to validate.\");\n  }\n\n  if (!filePath) {\n    throw new Error(\"Please provide a filePath.\");\n  }\n\n  if (!credsObj.clientId) {\n    throw new Error(\"\\\"clientId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n    throw new Error(\"Either \\\"clientSecret\\\" or \\\"clientCertificate\\\" must be present in the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.subscriptionId) {\n    throw new Error(\"\\\"subscriptionId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.tenantId) {\n    throw new Error(\"\\\"tenantId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.activeDirectoryEndpointUrl) {\n    throw new Error(\"\\\"activeDirectoryEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.resourceManagerEndpointUrl) {\n    throw new Error(\"\\\"resourceManagerEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.activeDirectoryGraphResourceId) {\n    throw new Error(\"\\\"activeDirectoryGraphResourceId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.sqlManagementEndpointUrl) {\n    throw new Error(\"\\\"sqlManagementEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n}\n\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n  if (!authFileUrl || authFileUrl && typeof authFileUrl.valueOf() !== \"string\") {\n    throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  if (!envUrl || envUrl && typeof envUrl.valueOf() !== \"string\") {\n    throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n  envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n  return authFileUrl.toLowerCase() === envUrl.toLowerCase();\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set â€“n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param {object} [options] - Optional parameters\n * @param {string} [options.filePath] - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param {string} [options.subscriptionEnvVariableName] - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\n\nfunction withAuthFileWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var filePath, subscriptionEnvVariableName, msg, content, credsObj, optionsForSp, envFound, envNames, i, env, environmentObj, envParams, keys, _i, key;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!options) options = {\n              filePath: \"\"\n            };\n            filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n            subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n\n            if (filePath) {\n              _context4.next = 6;\n              break;\n            }\n\n            msg = \"Either provide an absolute file path to the auth file or set/export the environment variable - \".concat(authConstants_1.AuthConstants.AZURE_AUTH_LOCATION, \".\");\n            throw new Error(msg);\n\n          case 6:\n            credsObj = {};\n            optionsForSp = {};\n            content = fs_1.readFileSync(filePath, {\n              encoding: \"utf8\"\n            });\n            credsObj = JSON.parse(content);\n            validateAuthFileContent(credsObj, filePath);\n\n            if (!credsObj.managementEndpointUrl) {\n              credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n            } // setting the subscriptionId from auth file to the environment variable\n\n\n            process.env[subscriptionEnvVariableName] = credsObj.subscriptionId; // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n\n            envFound = {\n              name: \"\"\n            };\n            envNames = Object.keys(ms_rest_azure_env_1.Environment);\n            i = 0;\n\n          case 16:\n            if (!(i < envNames.length)) {\n              _context4.next = 25;\n              break;\n            }\n\n            env = envNames[i];\n            environmentObj = ms_rest_azure_env_1.Environment[env];\n\n            if (!(environmentObj && environmentObj.managementEndpointUrl && foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl))) {\n              _context4.next = 22;\n              break;\n            }\n\n            envFound.name = environmentObj.name;\n            return _context4.abrupt(\"break\", 25);\n\n          case 22:\n            i++;\n            _context4.next = 16;\n            break;\n\n          case 25:\n            if (envFound.name) {\n              optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n            } else {\n              // create a new environment with provided info.\n              envParams = {\n                // try to find a logical name or set the filepath as the env name.\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n              };\n              keys = Object.keys(credsObj);\n\n              for (_i = 0; _i < keys.length; _i++) {\n                key = keys[_i];\n\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/ig) === null) {\n                  if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n                    envParams[key] = credsObj[key] + \"/\";\n                  } else {\n                    envParams[key] = credsObj[key];\n                  }\n                }\n              }\n\n              if (!envParams.activeDirectoryResourceId) {\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n              }\n\n              if (!envParams.portalUrl) {\n                envParams.portalUrl = \"https://portal.azure.com\";\n              }\n\n              optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n            }\n\n            if (!credsObj.clientSecret) {\n              _context4.next = 28;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp));\n\n          case 28:\n            return _context4.abrupt(\"return\", withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp));\n\n          case 29:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {object} [options] Object representing optional parameters.\n *\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferably in a guid format).\n *\n * @param {string} [options.domain] The domain or tenant Id containing this application. Default value is \"common\".\n *\n * @param {Environment} [options.environment] The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @param {object} [options.language] The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param {object|function} [options.userCodeResponseLogger] A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withInteractiveWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var interactiveOptions, authorityUrl, authContext, tryAcquireToken, getUserCode, userCodeResponse, creds, tenants, subscriptions;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            tryAcquireToken = function _tryAcquireToken(interactiveOptions, resolve, reject) {\n              authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, function (err, userCodeRes) {\n                if (err) {\n                  if (err.error === \"authorization_pending\") {\n                    setTimeout(function () {\n                      tryAcquireToken(interactiveOptions, resolve, reject);\n                    }, 1000);\n                  } else {\n                    reject(err);\n                  }\n\n                  return;\n                }\n\n                if (interactiveOptions.userCodeResponseLogger) {\n                  interactiveOptions.userCodeResponseLogger(userCodeRes.message);\n                } else {\n                  console.log(userCodeRes.message);\n                }\n\n                return resolve(userCodeRes);\n              });\n            };\n\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            if (!options.domain) {\n              options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n            }\n\n            if (!options.clientId) {\n              options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n            }\n\n            if (!options.tokenCache) {\n              options.tokenCache = new adal.MemoryCache();\n            }\n\n            if (!options.language) {\n              options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n            }\n\n            if (!options.tokenAudience) {\n              options.tokenAudience = options.environment.activeDirectoryResourceId;\n            }\n\n            interactiveOptions = {};\n            interactiveOptions.tokenAudience = options.tokenAudience;\n            interactiveOptions.environment = options.environment;\n            interactiveOptions.domain = options.domain;\n            interactiveOptions.clientId = options.clientId;\n            interactiveOptions.tokenCache = options.tokenCache;\n            interactiveOptions.language = options.language;\n            interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n            authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n            authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n            interactiveOptions.context = authContext;\n            getUserCode = new Promise(function (resolve, reject) {\n              return tryAcquireToken(interactiveOptions, resolve, reject);\n            });\n            _context5.next = 22;\n            return getUserCode;\n\n          case 22:\n            userCodeResponse = _context5.sent;\n            _context5.next = 25;\n            return new Promise(function (resolve, reject) {\n              return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, function (error, tokenResponse) {\n                if (error) {\n                  return reject(error);\n                }\n\n                var response = tokenResponse;\n                interactiveOptions.userName = response.userId;\n                interactiveOptions.authorizationScheme = response.tokenType;\n                var creds;\n\n                try {\n                  creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n                } catch (err) {\n                  return reject(err);\n                }\n\n                return resolve(creds);\n              });\n            });\n\n          case 25:\n            creds = _context5.sent;\n            _context5.next = 28;\n            return subscriptionUtils_1.buildTenantList(creds);\n\n          case 28:\n            tenants = _context5.sent;\n            _context5.next = 31;\n            return _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n\n          case 31:\n            subscriptions = _context5.sent;\n            return _context5.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptions\n            });\n\n          case 33:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\n\nfunction withAuthFile(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withAuthFileWithAuthResponse(options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withAuthFileWithAuthResponse(options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withAuthFile = withAuthFile;\n\nfunction interactive(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withInteractiveWithAuthResponse(options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withInteractiveWithAuthResponse(options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.interactive = interactive;\n\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\n\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\n\nfunction withUsernamePassword(username, password, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withUsernamePasswordWithAuthResponse(username, password, options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\n\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n  if (tokenAudience && !managementPlaneTokenAudiences.some(function (item) {\n    return item === tokenAudience.toLowerCase();\n  })) {\n    return Promise.resolve([]);\n  }\n\n  return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param {string} domain - required. The tenant id.\n * @param {object} options - Optional parameters\n * @param {string} [options.port] - port on which the MSI service is running on the host VM. Default port is 50342\n * @param {string} [options.resource] - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param {string} [options.aadEndpoint] - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param {any} callback - the callback function.\n */\n\n\nfunction _withMSI(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var creds;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n            _context6.next = 4;\n            return creds.getToken();\n\n          case 4:\n            return _context6.abrupt(\"return\", creds);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n}\n\nfunction loginWithVmMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return _withMSI(options);\n  } else {\n    msRest.promiseToCallback(_withMSI(options))(function (err, tokenRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\n\nfunction _withAppServiceMSI(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var creds;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n            _context7.next = 4;\n            return creds.getToken();\n\n          case 4:\n            return _context7.abrupt(\"return\", creds);\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n}\n\nfunction loginWithAppServiceMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return _withAppServiceMSI(options);\n  } else {\n    msRest.promiseToCallback(_withAppServiceMSI(options))(function (err, tokenRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmd The az cli command to execute.\n */\n\nfunction execAz(cmd) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new Promise(function (resolve, reject) {\n              child_process_1.exec(\"az \".concat(cmd, \" --out json\"), {\n                encoding: \"utf8\"\n              }, function (error, stdout) {\n                if (error) {\n                  return reject(error);\n                }\n\n                if (stdout) {\n                  try {\n                    return resolve(JSON.parse(stdout));\n                  } catch (err) {\n                    var msg = \"An error occurred while parsing the output \\\"\".concat(stdout, \"\\\", of \") + \"the cmd \\\"\".concat(cmd, \"\\\": \").concat(err.stack, \".\");\n                    return reject(new Error(msg));\n                  }\n                }\n\n                return resolve();\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n}\n\nexports.execAz = execAz;","map":{"version":3,"sources":["../../lib/login.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst adal = require(\"adal-node\");\nconst msRest = require(\"@azure/ms-rest-js\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\nconst applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\nconst applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\nconst deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\nconst userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\nconst authConstants_1 = require(\"./util/authConstants\");\nconst subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\nconst msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\nconst msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * @constant {Array<string>} managementPlaneTokenAudiences - Urls for management plane token\n * audience across different azure environments.\n */\nconst managementPlaneTokenAudiences = [\n    \"https://management.core.windows.net/\",\n    \"https://management.core.chinacloudapi.cn/\",\n    \"https://management.core.usgovcloudapi.net/\",\n    \"https://management.core.cloudapi.de/\",\n    \"https://management.azure.com/\",\n    \"https://management.core.windows.net\",\n    \"https://management.core.chinacloudapi.cn\",\n    \"https://management.core.usgovcloudapi.net\",\n    \"https://management.core.cloudapi.de\",\n    \"https://management.azure.com\"\n];\nfunction turnOnLogging() {\n    const log = adal.Logging;\n    log.setLoggingOptions({\n        level: 3,\n        log: function (level, message, error) {\n            level;\n            console.info(message);\n            if (error) {\n                console.error(error);\n            }\n        }\n    });\n}\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n    turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {string} username The user name for the Organization Id account.\n * @param {string} password The password for the Organization Id account.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param {string} [options.domain] The domain or tenant Id containing this application. Default value \"common\".\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains `credentials` and an optional `subscriptions` array, and rejects with an Error.\n */\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.clientId) {\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n        }\n        if (!options.domain) {\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        const creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment);\n        const tokenResponse = yield creds.getToken();\n        // The token cache gets propulated for all the tenants as a part of building the tenantList.\n        let tenantList = yield subscriptionUtils_1.buildTenantList(creds);\n        if (tenantList.length === 0 && tokenResponse.tenantId) {\n            tenantList = [tokenResponse.tenantId];\n        }\n        const subscriptionList = yield _getSubscriptions(creds, tenantList, options.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptionList };\n    });\n}\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {string} clientId The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} secret The application secret for the service principal.\n * @param {string} domain The domain or tenant Id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        const creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment);\n        yield creds.getToken();\n        const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptionList };\n    });\n}\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {string} clientId The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} certificateStringOrFilePath A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param {string} domain The domain or tenant Id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        const creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n        yield creds.getToken();\n        const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptionList };\n    });\n}\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\nfunction validateAuthFileContent(credsObj, filePath) {\n    if (!credsObj) {\n        throw new Error(\"Please provide a credsObj to validate.\");\n    }\n    if (!filePath) {\n        throw new Error(\"Please provide a filePath.\");\n    }\n    if (!credsObj.clientId) {\n        throw new Error(`\"clientId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n        throw new Error(`Either \"clientSecret\" or \"clientCertificate\" must be present in the auth file: ${filePath}.`);\n    }\n    if (!credsObj.subscriptionId) {\n        throw new Error(`\"subscriptionId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.tenantId) {\n        throw new Error(`\"tenantId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.activeDirectoryEndpointUrl) {\n        throw new Error(`\"activeDirectoryEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.resourceManagerEndpointUrl) {\n        throw new Error(`\"resourceManagerEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.activeDirectoryGraphResourceId) {\n        throw new Error(`\"activeDirectoryGraphResourceId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.sqlManagementEndpointUrl) {\n        throw new Error(`\"sqlManagementEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n}\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n    if (!authFileUrl || (authFileUrl && typeof authFileUrl.valueOf() !== \"string\")) {\n        throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n    }\n    if (!envUrl || (envUrl && typeof envUrl.valueOf() !== \"string\")) {\n        throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n    }\n    authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n    envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n    return (authFileUrl.toLowerCase() === envUrl.toLowerCase());\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set â€“n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param {object} [options] - Optional parameters\n * @param {string} [options.filePath] - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param {string} [options.subscriptionEnvVariableName] - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withAuthFileWithAuthResponse(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options)\n            options = { filePath: \"\" };\n        const filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n        const subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n        if (!filePath) {\n            const msg = `Either provide an absolute file path to the auth file or set/export the environment variable - ${authConstants_1.AuthConstants.AZURE_AUTH_LOCATION}.`;\n            throw new Error(msg);\n        }\n        let content, credsObj = {};\n        const optionsForSp = {};\n        content = fs_1.readFileSync(filePath, { encoding: \"utf8\" });\n        credsObj = JSON.parse(content);\n        validateAuthFileContent(credsObj, filePath);\n        if (!credsObj.managementEndpointUrl) {\n            credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n        }\n        // setting the subscriptionId from auth file to the environment variable\n        process.env[subscriptionEnvVariableName] = credsObj.subscriptionId;\n        // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n        const envFound = {\n            name: \"\"\n        };\n        const envNames = Object.keys(ms_rest_azure_env_1.Environment);\n        for (let i = 0; i < envNames.length; i++) {\n            const env = envNames[i];\n            const environmentObj = ms_rest_azure_env_1.Environment[env];\n            if (environmentObj &&\n                environmentObj.managementEndpointUrl &&\n                foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl)) {\n                envFound.name = environmentObj.name;\n                break;\n            }\n        }\n        if (envFound.name) {\n            optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n        }\n        else {\n            // create a new environment with provided info.\n            const envParams = {\n                // try to find a logical name or set the filepath as the env name.\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n            };\n            const keys = Object.keys(credsObj);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/ig) === null) {\n                    if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n                        envParams[key] = credsObj[key] + \"/\";\n                    }\n                    else {\n                        envParams[key] = credsObj[key];\n                    }\n                }\n            }\n            if (!envParams.activeDirectoryResourceId) {\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n            }\n            if (!envParams.portalUrl) {\n                envParams.portalUrl = \"https://portal.azure.com\";\n            }\n            optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n        }\n        if (credsObj.clientSecret) {\n            return withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp);\n        }\n        return withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp);\n    });\n}\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param {object} [options] Object representing optional parameters.\n *\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferably in a guid format).\n *\n * @param {string} [options.domain] The domain or tenant Id containing this application. Default value is \"common\".\n *\n * @param {Environment} [options.environment] The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @param {object} [options.language] The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param {object|function} [options.userCodeResponseLogger] A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withInteractiveWithAuthResponse(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        if (!options.domain) {\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n        }\n        if (!options.clientId) {\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n        }\n        if (!options.tokenCache) {\n            options.tokenCache = new adal.MemoryCache();\n        }\n        if (!options.language) {\n            options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n        }\n        if (!options.tokenAudience) {\n            options.tokenAudience = options.environment.activeDirectoryResourceId;\n        }\n        const interactiveOptions = {};\n        interactiveOptions.tokenAudience = options.tokenAudience;\n        interactiveOptions.environment = options.environment;\n        interactiveOptions.domain = options.domain;\n        interactiveOptions.clientId = options.clientId;\n        interactiveOptions.tokenCache = options.tokenCache;\n        interactiveOptions.language = options.language;\n        interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n        const authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n        const authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n        interactiveOptions.context = authContext;\n        function tryAcquireToken(interactiveOptions, resolve, reject) {\n            authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, (err, userCodeRes) => {\n                if (err) {\n                    if (err.error === \"authorization_pending\") {\n                        setTimeout(() => {\n                            tryAcquireToken(interactiveOptions, resolve, reject);\n                        }, 1000);\n                    }\n                    else {\n                        reject(err);\n                    }\n                    return;\n                }\n                if (interactiveOptions.userCodeResponseLogger) {\n                    interactiveOptions.userCodeResponseLogger(userCodeRes.message);\n                }\n                else {\n                    console.log(userCodeRes.message);\n                }\n                return resolve(userCodeRes);\n            });\n        }\n        const getUserCode = new Promise((resolve, reject) => {\n            return tryAcquireToken(interactiveOptions, resolve, reject);\n        });\n        const userCodeResponse = yield getUserCode;\n        const creds = yield new Promise((resolve, reject) => {\n            return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, (error, tokenResponse) => {\n                if (error) {\n                    return reject(error);\n                }\n                const response = tokenResponse;\n                interactiveOptions.userName = response.userId;\n                interactiveOptions.authorizationScheme = response.tokenType;\n                let creds;\n                try {\n                    creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n                }\n                catch (err) {\n                    return reject(err);\n                }\n                return resolve(creds);\n            });\n        });\n        const tenants = yield subscriptionUtils_1.buildTenantList(creds);\n        const subscriptions = yield _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptions };\n    });\n}\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\nfunction withAuthFile(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withAuthFileWithAuthResponse(options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withAuthFileWithAuthResponse(options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withAuthFile = withAuthFile;\nfunction interactive(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withInteractiveWithAuthResponse(options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withInteractiveWithAuthResponse(options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.interactive = interactive;\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\nfunction withUsernamePassword(username, password, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withUsernamePasswordWithAuthResponse(username, password, options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n    if (tokenAudience &&\n        !managementPlaneTokenAudiences.some((item) => { return item === tokenAudience.toLowerCase(); })) {\n        return Promise.resolve([]);\n    }\n    return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param {string} domain - required. The tenant id.\n * @param {object} options - Optional parameters\n * @param {string} [options.port] - port on which the MSI service is running on the host VM. Default port is 50342\n * @param {string} [options.resource] - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param {string} [options.aadEndpoint] - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param {any} callback - the callback function.\n */\nfunction _withMSI(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        const creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n        yield creds.getToken();\n        return creds;\n    });\n}\nfunction loginWithVmMSI(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    const cb = callback;\n    if (!callback) {\n        return _withMSI(options);\n    }\n    else {\n        msRest.promiseToCallback(_withMSI(options))((err, tokenRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, tokenRes);\n        });\n    }\n}\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\nfunction _withAppServiceMSI(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        const creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n        yield creds.getToken();\n        return creds;\n    });\n}\nfunction loginWithAppServiceMSI(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    const cb = callback;\n    if (!callback) {\n        return _withAppServiceMSI(options);\n    }\n    else {\n        msRest.promiseToCallback(_withAppServiceMSI(options))((err, tokenRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, tokenRes);\n        });\n    }\n}\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmd The az cli command to execute.\n */\nfunction execAz(cmd) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            child_process_1.exec(`az ${cmd} --out json`, { encoding: \"utf8\" }, (error, stdout) => {\n                if (error) {\n                    return reject(error);\n                }\n                if (stdout) {\n                    try {\n                        return resolve(JSON.parse(stdout));\n                    }\n                    catch (err) {\n                        const msg = `An error occurred while parsing the output \"${stdout}\", of ` +\n                            `the cmd \"${cmd}\": ${err.stack}.`;\n                        return reject(new Error(msg));\n                    }\n                }\n                return resolve();\n            });\n        });\n    });\n}\nexports.execAz = execAz;\n//# sourceMappingURL=login.js.map"]},"metadata":{},"sourceType":"script"}